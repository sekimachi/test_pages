<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>webイラスト保管庫α版</title>
<style>
  :root{
    --card-w:150px;
    --card-gap:10px;
  }
  body{
    font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    padding:20px;
    background:#f7f7f7;
    margin:0;
  }
  h1{margin:0 0 14px 0;}
  #addGenreBtn{
    padding:8px 12px;border:0;border-radius:6px;background:#4aa3ff;color:#fff;cursor:pointer;margin-bottom:18px;
  }

  /* container for all genres */
  #genres{position:relative;}

/* ----- genre box ----- */
  .genre{
    background:#fff;padding:14px;border-radius:10px;margin-bottom:18px;
    box-shadow:0 2px 6px rgba(0,0,0,0.06);border:2px solid transparent;position:relative;
  }
  .genre.dragging{opacity:0.6;border:2px dashed #4aa3ff}
  .genre-header{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:10px}
  .genre-title{font-size:18px;font-weight:600;cursor:text}
  .title-controls{display:flex;gap:8px;align-items:center}

/* ----- gallery ----- */
.gallery{
    display:flex;flex-wrap:nowrap;gap:var(--card-gap);
    overflow-x:auto;  /* スクロール可能に */
    scroll-behavior: smooth;  /* ← ここでアニメーションを追加 */
    padding:6px 8px 10px 8px;
    border-radius:8px;
    background:linear-gradient(180deg,#ffffff,#fbfbfb);
    min-height:140px;
    scrollbar-width:none; /* Firefox scrollbar非表示 */
}
.gallery::-webkit-scrollbar{
    display:none; /* Chrome, Edge, Safari scrollbar非表示 */
}


/* card */
  .img-card{
    width:var(--card-w);flex:0 0 auto;background:#fff;border:1px solid #e6e6e6;border-radius:8px;padding:6px;position:relative;
    box-shadow:0 1px 1px rgba(0,0,0,0.03);
  }
  .img-card img{width:100%;height:120px;object-fit:cover;border-radius:6px;display:block;cursor:pointer}

/* setting button */
  .setting-btn{
    position:absolute;top:6px;right:6px;width:26px;height:26px;border-radius:50%;
    background:#fff;border:1px solid #cfcfcf;display:flex;align-items:center;justify-content:center;cursor:pointer;
    box-shadow:0 1px 2px rgba(0,0,0,0.06);
  }

/* setting menu */
  .setting-menu{
    position:absolute;top:36px;right:6px;background:#fff;border:1px solid #ddd;border-radius:6px;padding:6px;display:none;flex-direction:column;gap:6px;z-index:8;
  }
  .setting-item{padding:6px 10px;background:#f2f2f2;border-radius:6px;cursor:pointer;text-align:center}
  .setting-item:hover{background:#e6e6e6}

/* ----- overlay upload inside gallery ----- */
  .upload-overlay{
    position:absolute;left:8px;right:8px;top:8px;bottom:8px;
    display:flex;align-items:center;justify-content:center;
    border-radius:8px;
    pointer-events:none; /* we enable pointer-events on inner area when active */
  }
  .upload-area{
    pointer-events:none;
    width:100%;height:100%;
    border:2px dashed rgba(74,163,255,0.9);
    background:rgba(255,255,255,0.65);
    display:flex;align-items:center;justify-content:center;border-radius:6px;
    color:#1478c7;font-size:18px;opacity:0;transform:scale(0.98);
    transition:opacity .12s, transform .12s;
  }
.upload-area.active{
    opacity:1;
    transform:scale(1);
    pointer-events:none;   /* active でもクリック不可のまま */
}
  .upload-area .hint{padding:8px 12px;border-radius:6px;background:transparent}

/* ----- upload button in title ----- */
  .add-image-btn{
    padding:6px 10px;border-radius:6px;border:0;background:#4aa3ff;color:#fff;cursor:pointer;
    font-size:13px;
  }

/* ----- left/right scroll buttons ----- */
  .slide-btn{
    position:absolute;top:50%;transform:translateY(-50%);background:#4aa3ff;color:#fff;border:0;border-radius:50%;
    width:36px;height:36px;cursor:pointer;z-index:6;display:flex;align-items:center;justify-content:center;
  }
  .slide-left{left:6px}
  .slide-right{right:6px}

/* ----- modal ----- */
  .modal{display:none;position:fixed;z-index:120;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.75);align-items:center;justify-content:center;padding:24px}
  .modal img{max-width:100%;max-height:100%;border-radius:8px;box-shadow:0 6px 30px rgba(0,0,0,0.5)}
  .modal-close{position:absolute;top:18px;right:24px;font-size:36px;color:#fff;cursor:pointer}

/* small utilities */
  .flex-row{display:flex;align-items:center;gap:8px}
  input[type="file"]{display:none}
</style>
</head>
<body>

<h1>webイラスト保管庫α版</h1>
<button id="addGenreBtn">＋ ジャンルを追加</button>

<div id="genres"></div>

<!-- Modal -->
<div id="modal" class="modal" role="dialog" aria-hidden="true">
  <span class="modal-close" aria-label="閉じる">×</span>
  <img id="modalImage" alt="拡大画像">
</div>

<script>
/* ---------------------------
   IndexedDB (simple wrapper)
   keyPath: id (we create id ourselves)
----------------------------*/
const DB_NAME = 'IllustVaultDB_v2';
const STORE = 'genres';

let dbPromise = null;
function openDB(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = e => {
      const db = e.target.result;
      if(!db.objectStoreNames.contains(STORE)){
        db.createObjectStore(STORE, { keyPath: 'id' });
      }
    };
    req.onsuccess = e => resolve(e.target.result);
    req.onerror = e => reject(e.target.error);
  });
}
async function getDB(){ if(!dbPromise) dbPromise = openDB(); return dbPromise; }

async function saveGenres(genres){
  const db = await getDB();
  const tx = db.transaction(STORE, 'readwrite');
  const store = tx.objectStore(STORE);
  await store.clear();
  for(const g of genres) store.add(g);
  return tx.complete;
}
async function loadGenres(){
  const db = await getDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE, 'readonly');
    const s = tx.objectStore(STORE);
    const r = s.getAll();
    r.onsuccess = () => {
      // ensure images.blob are Blobs (likely ok)
      res(r.result || []);
    };
    r.onerror = () => rej(r.error);
  });
}

/* ---------------------------
   App state
----------------------------*/
let genres = [];

(async function init(){
  genres = await loadGenres();
  renderGenres();
})();

/* Add genre button */
document.getElementById('addGenreBtn').addEventListener('click', ()=>{
  const newGenre = { id: Date.now().toString(), name: '新しいジャンル', images: [] };
  genres.push(newGenre);
  saveGenres(genres);
  renderGenres();
});

/* ---------------------------
   Render
----------------------------*/
const genresContainer = document.getElementById('genres');

function renderGenres(){
  genresContainer.innerHTML = '';

  genres.forEach((genre, gi) => {
    const box = document.createElement('div');
    box.className = 'genre';
    box.draggable = true;

    /* genre drag (order change) - preserved */
    box.addEventListener('dragstart', e => {
      box.classList.add('dragging');
      e.dataTransfer.setData('text/plain', String(gi));
    });
    box.addEventListener('dragend', () => box.classList.remove('dragging'));
    box.addEventListener('dragover', e => {
      e.preventDefault();
      const from = parseInt(e.dataTransfer.getData('text/plain'), 10);
      if (Number.isNaN(from) || from === gi) return;
      const moving = genres.splice(from, 1)[0];
      genres.splice(gi, 0, moving);
      saveGenres(genres);
      renderGenres();
    });

    /* header: title + add image button */
    const header = document.createElement('div');
    header.className = 'genre-header';

    const title = document.createElement('div');
    title.className = 'genre-title';
    title.textContent = genre.name;
    title.contentEditable = false;
    title.addEventListener('click', ()=> {
      title.contentEditable = true;
      title.focus();
    });
    title.addEventListener('blur', ()=> {
      title.contentEditable = false;
      genre.name = title.textContent.trim() || '無題のジャンル';
      saveGenres(genres);
    });

    const titleControls = document.createElement('div');
    titleControls.className = 'title-controls';

    const addBtn = document.createElement('button');
    addBtn.className = 'add-image-btn';
    addBtn.textContent = '＋画像を追加';
    // hidden input for file selection
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.multiple = true;
    fileInput.addEventListener('change', async () => {
      await handleAddFiles(fileInput.files, genre);
      fileInput.value = '';
    });
    addBtn.addEventListener('click', () => fileInput.click());

    titleControls.appendChild(addBtn);
    titleControls.appendChild(fileInput);

    header.appendChild(title);
    header.appendChild(titleControls);

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'add-image-btn';
    deleteBtn.style.background = '#ff4d4f'; // 赤系
    deleteBtn.textContent = '削除';
    deleteBtn.addEventListener('click', () => {
        const ok = confirm(`ジャンル「${genre.name}」を削除してもよろしいですか？`);
        if(ok){
            genres.splice(gi, 1); // 配列から削除
            saveGenres(genres);
            renderGenres();
        }
    });

    titleControls.appendChild(deleteBtn);

    /* gallery wrap */
    const galleryWrap = document.createElement('div');
    galleryWrap.className = 'gallery-wrap';

    /* left/right scroll buttons */
    const btnL = document.createElement('button');
    btnL.className = 'slide-btn slide-left';
    btnL.type = 'button';
    btnL.textContent = '＜';
    btnL.addEventListener('click', () => scrollGallery(gallery, -1));

    const btnR = document.createElement('button');
    btnR.className = 'slide-btn slide-right';
    btnR.type = 'button';
    btnR.textContent = '＞';
    btnR.addEventListener('click', () => scrollGallery(gallery, +1));

    /* gallery itself (no native scrollbar visible) */
    const gallery = document.createElement('div');
    gallery.className = 'gallery';
    // set aria
    gallery.setAttribute('role','list');

    /* upload overlay positioned over gallery (hidden until dragover or hover) */
    const overlayHolder = document.createElement('div');
    overlayHolder.className = 'upload-overlay';

    const uploadArea = document.createElement('div');
    uploadArea.className = 'upload-area';
    const hint = document.createElement('div');
    hint.className = 'hint';
    hint.innerText = 'ここにドラッグ＆ドロップ または クリックして追加';
    uploadArea.appendChild(hint);
    overlayHolder.appendChild(uploadArea);

    // overlay click -> file dialog
    uploadArea.addEventListener('click', ()=> fileInput.click());

    // dragenter/dragleave/drop inside gallery area
    let dragCounter = 0;
    gallery.addEventListener('dragenter', e => {
      e.preventDefault();
      dragCounter++;
      uploadArea.classList.add('active');
    });
    gallery.addEventListener('dragover', e => { e.preventDefault(); });
    gallery.addEventListener('dragleave', e => {
      e.preventDefault();
      dragCounter--;
      if(dragCounter <= 0){ dragCounter = 0; uploadArea.classList.remove('active'); }
    });
    gallery.addEventListener('drop', async e => {
      e.preventDefault();
      dragCounter = 0;
      uploadArea.classList.remove('active');
      const files = [...e.dataTransfer.files].filter(f => f.type && f.type.startsWith('image/'));
      if(files.length) await handleAddFiles(files, genre);
    });

    /* render images (no drag sorting) */
    genre.images.forEach((imgObj, idx) => {
      const card = document.createElement('div');
      card.className = 'img-card';

      const img = document.createElement('img');
      // imgObj.blob might be a File/Blob or already a stored Blob from IndexedDB
      try {
        img.src = URL.createObjectURL(imgObj.blob);
      } catch (err) {
        // fallback: if stored as data URL string, use it
        img.src = imgObj.dataUrl || '';
      }
      img.alt = imgObj.name || '';

      // click -> modal
      img.addEventListener('click', ()=> {
        openModal(img.src);
      });

      // setting button
      const setBtn = document.createElement('button');
      setBtn.className = 'setting-btn';
      setBtn.type = 'button';
      setBtn.title = '設定';
      setBtn.textContent = '⚙';

      const menu = document.createElement('div');
      menu.className = 'setting-menu';

      // delete item
      const del = document.createElement('div');
      del.className = 'setting-item';
      del.textContent = '削除';
      del.addEventListener('click', ()=> {
        // remove image at idx
        genre.images.splice(idx, 1);
        saveGenres(genres);
        renderGenres();
      });

      // replace item
      const rep = document.createElement('div');
      rep.className = 'setting-item';
      rep.textContent = '画像差し替え';
      rep.addEventListener('click', ()=> {
        const replacer = document.createElement('input');
        replacer.type = 'file';
        replacer.accept = 'image/*';
        replacer.onchange = async () => {
          const f = replacer.files[0];
          if(!f) return;
          const blob = new Blob([await f.arrayBuffer()], { type: f.type });
          genre.images[idx] = { name: f.name, blob };
          saveGenres(genres);
          renderGenres();
        };
        replacer.click();
      });

      menu.appendChild(del);
      menu.appendChild(rep);

      // toggle menu on setBtn click
      setBtn.addEventListener('click', (ev)=> {
        ev.stopPropagation();
        // hide any other menus
        document.querySelectorAll('.setting-menu').forEach(m=>{ if(m!==menu) m.style.display='none'; });
        menu.style.display = (menu.style.display === 'flex') ? 'none' : 'flex';
      });

      // click outside closes menus
      document.addEventListener('click', (ev)=> {
        if(!menu.contains(ev.target) && ev.target !== setBtn) menu.style.display = 'none';
      });

      card.appendChild(img);
      card.appendChild(setBtn);
      card.appendChild(menu);

      gallery.appendChild(card);
    });

    /* append components */
    galleryWrap.appendChild(btnL);
    galleryWrap.appendChild(gallery);
    galleryWrap.appendChild(btnR);
    galleryWrap.appendChild(overlayHolder);

    box.appendChild(header);
    box.appendChild(galleryWrap);

    genresContainer.appendChild(box);
  });

  // After DOM inserted, ensure galleries update widths for scroll calculations
}

/* ---------------------------
   Add files to a genre and save
   files: FileList or Array of File-like
----------------------------*/
async function handleAddFiles(files, genre){
  const arr = Array.from(files).filter(f => f.type && f.type.startsWith('image/'));
  for(const f of arr){
    const blob = new Blob([await f.arrayBuffer()], { type: f.type });
    // 先頭に追加して左側に表示
    genre.images.unshift({ name: f.name, blob });
  }
  await saveGenres(genres);
  renderGenres();
}

/* ---------------------------
   Scroll gallery by number of visible cards
   dir: +1 or -1
----------------------------*/
function scrollGallery(gallery, dir){
  // gallery is element reference or selector – ensure we have element
  // if gallery parameter is the element created earlier, good; otherwise find
  if(!gallery) return;
  const cardW = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-w')) || 150;
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-gap')) || 10;
  const totalCardW = cardW + gap;
  const viewCount = Math.max(1, Math.floor(gallery.clientWidth / totalCardW));
  gallery.scrollLeft += dir * (totalCardW * viewCount);
}

/* ---------------------------
   Modal
----------------------------*/
const modal = document.getElementById('modal');
const modalImg = document.getElementById('modalImage');
const modalClose = document.querySelector('.modal-close');

function openModal(src){
  modalImg.src = src;
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden','false');
}
modalClose.addEventListener('click', ()=> {
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden','true');
});
modal.addEventListener('click', (e)=> {
  if(e.target === modal) {
    modal.style.display = 'none';
    modal.setAttribute('aria-hidden','true');
  }
});

/* ---------------------------
   Utility: load/save on page load/unload
----------------------------*/
/* ensure we render initial state on load already called in init */

/* that's all — initial render done earlier */
</script>

</body>
</html>
